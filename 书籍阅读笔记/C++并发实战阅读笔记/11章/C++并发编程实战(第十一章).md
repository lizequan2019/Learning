# 多线程应用的测试和除错  

&emsp;&emsp;本章内容

* 并发相关错误 
* 通过测试和代码审查查找错误
* 设计多线程测试
* 测试多线程代码的性能


&emsp;&emsp;到目前为止，我们主要关注编写并发代码所涉及的内容、可用的工具、如何使用它们以及代码的总体设计和结构。但软件开发中有一个关键部分我还没有解决：测试和调试。如果您正在阅读本章，希望有一种简单的方法来测试并发代码，那么您将非常失望。测试和调试并发代码很困难。我要给你们的是一些让事情变得更容易的技巧，以及一些需要思考的重要问题。


## 11.1 与并发相关的错误类型

&emsp;&emsp;您可以在并发代码中得到任何类型的bug；但有些类型的bug与并发的使用直接相关，所以本书会针对这些类型的错误进行分析和讲解。通常，这些与并发关联的错误分为两大类型:

* 多余的阻塞 
* 条件竞争  


### 11.1.1 多余的阻塞 

&emsp;&emsp;**多余的阻塞**是什么意思？一个线程因为等待某件事而不能继续执行被称作阻塞，等待的事情可能是互斥锁、条件变量、`future`对象，甚至是I/O操作。虽然上述的事情都是多线程程序的自然组成部分，但是不能随意使用，否则会导致多余的阻塞。这就引出了下一个问题:为什么不想要阻塞发生？通常，若一个线程被阻塞，而逼的线程又在等待该线程执行某项操作，则后面的等待线程也被迫阻塞。上述情形有几种变化:

* **死锁** : 正如您在第3章中看到的，在死锁的情况下，A线程在等待B线程，而B则在等待A。如果线程死锁，那么它们应该执行的任务将无法完成。最明显的场景是，所涉及的线程之一是负责用户界面的线程，在这种情况下，界面将停止响应。在其他情况下，界面将保持响应，但一些必需的任务将无法完成，例如查找不会返回结果或文档无法打印。  

* **活锁** : 与死锁类似，A线程在等待B线程，而B则在等待A线程。死锁和活锁的关键区别在于，活锁的等待不是阻塞等待，而是处于活动状态的检查循环，例如自旋锁。在严重的情况下，活锁与死锁相同(应用程序不继续向下进行)。但不同之处是，活锁令CPU使用率很高，因为线程还在运行，只不过互相阻碍着对方。在不太严重的情况下，活锁最终会因线程的随机调度而被解开。尽管这样，被活锁影响的线程依然会有很大延迟性，在延迟期间CPU使用率会很高。

* **I/O阻塞或其他外部阻塞** : 若线程在等待外部输入时被阻塞，它就无法继续。因此，如果一个线程正在等待着另一个线程完成任务，则后者不应该再因外部输入而阻塞。 

&emsp;&emsp;上面是对多余的阻塞的简介。那条件竞争又如何呢？



### 11.1.2 条件竞争 

&emsp;&emsp;多线程代码中，条件竞争是各种问题最常见诱因之一，许多死锁和活锁都是因为竞争条件而出现的。并非所有竞争条件都是恶性竞争。例如，就任务队列而言，有哪个工作线程执行下一项任务无关紧要。然而许多并发问题的诱因还是条件竞争。条件竞争经常造成的问题类型如下:  

* **数据竞争**  数据竞争是一种特别的竞争条件，产生原因是对共享内存的非同步并发访问，进而导致的未定义行为。我在第5章分析C++内存模型时介绍了数据竞争。数据竞争通常是通过不正确地使用原子操作来同步线程，或者没有恰当地锁住互斥而访问共享数据。  

* **破坏了不变量(invariants)** : 其表现形式为悬空指针(当前线程正在通过指针访问目标数据，而其他线程却同时删除指针)、内存(random memory)数据损坏(数据正更新到一半，而其他线程却同时读取，造成数据不一致)、重复释放内存(两个线程同时从队列弹出相同的值，它们都删除某份关联的数据)等。不变量的破坏与时间相关，也与程序中的值相关。若多个线程上的多个操作需要按特定次序执行，有时候错误的同步方式会破坏特定次序而导致条件竞争。  

* **生存周期问题** : 尽管这类问题可以划归为不变量被破坏，但还是将其作为一个独立分类。这类错误中最基本的问题是，线程的生存期比它要访问的数据生存期长。数据被删除或以其他方式销毁后，线程仍试图访问它们，而相应的存储空间有可能已被另一个对象重用。出现生存期问题的情形往往是，线程引用了一个外部的局部变量，局部变量生存期已经结束，但是线程函数还没有执行完，此时线程函数就是访问了一个失效的引用。但是产生问题的情形不限于此。即使线程的生存期和它所操作的目标数据无关，数据还是有可能在线程结束之前销毁，令线程函数脱离正轨。若我们手动调用join()以等待线程结束，就要保证join()的调用不会出现异常而跳过。这是异常安全最基本的要求，多线程代码都使用。  

&emsp;&emsp;条件竞争有时是致命的。无论发生死锁还是活锁，应用软件都会像处于挂起状态一样，完全没有响应，或用很长时间才能完成任务。通常，若多线程程序发生了死锁或活锁，我们可以在其所属的进程附着运行调试工具，以确定这些线程在哪些同步对象上发生纠缠。

&emsp;&emsp;数据竞争、受到破坏的不变量和生存期问题都将产生可见的后果(形式为无规律崩溃、错误的输出)，它们会在代码的任何部分造成问题。代码可能改写其他系统另一部分使用的内存，直到很久以后才被使用。出现的问题可能与造成错误的代码毫无联系，并且可能在程序运行很长时间后才暴露。对对共享内存系统而言，是致命的。无论我们如何尽力限制哪个线程可以访问哪些数据，并试图确保使用正确的同步，但任何线程都可以覆盖应用程序中任何其他线程正在使用的数据。

&emsp;&emsp;前文已经简单地明确了有哪些错误需要处理。接着，我们来看看能够采用什么技法在代码中定位实际的错误并进行根除。



## 11.2 定位并发相关错误的技术

&emsp;&emsp;在上一节中，了解可能会见到的并发相关错误的类型以及它们在代码中的表现方式。这样便可以审查自己的代码，看看错误可能在哪里，以及如何判定在特定区域的代码中是否存在错误。  

&emsp;&emsp;也许最明显、最直接的做法是查看代码。虽然这看起来很明显，但很难做到彻底。因为审查自己的代码时，很容易将其按照原来的设计思路理解，难以辨识其中潜在的错误。同样，在审查其他人编写的代码时，容易倾向快速阅读，只进行简单的编码规范的检查，然后标注出来。真正需要投入时间的是各种并发\非并发错误，唯有悉心梳理代码并认真思考方可察觉。

&emsp;&emsp;即便代码经过全面审查，也可能会有遗漏，如果实在无力根除，那么在任何情况下，我们都至少要确定代码能够运作。下面，我们将继续学习代码审查，再过度到多线程代码测试的几种方法。

### 11.2.1 审查代码并定位潜在错误

&emsp;&emsp;正如我已经提到的，当审查多线程代码以查到与并发相关的bug时，必须彻底进行彻底检查。如果可能的话还需要请别人审查。因为他们没有编写此代码，所以他们必须仔细考虑它是如何工作的，这将有助于发现可能存在的任何错误。重要的是，审核人有充足时间进行深思熟虑的审稿，而不是随便的两分钟快速浏览。

&emsp;&emsp;如果让你的一个同事来检查代码，他们会觉得代码有新鲜感，因此，他们会从不同的角度出发，并可能发现自己无法发现的问题。  

&emsp;&emsp;如果没有别人帮自己审核代码，那么自己也可以检查，可以将代码放置一段时间，然后再回头看，此时代码会变得陌生。或者，自己解释一遍自己的代码，每当解释时也要扪心自问是否编写合适。



&emsp;&emsp;**查看多线程代码时要考虑的问题**
&emsp;&emsp;对于审阅者(无论是代码的作者还是其他人)来说，思考与正在审阅的代码相关的特定问题是很有用的。这些问题可以使审阅者的注意力集中在代码的相关细节上，并有助于识别潜在的问题。我想问的问题包括以下几点，尽管这绝对不是一个详尽的列表。你可能会发现其他问题有助于你更好地集中注意力。

* 如果要进行并发访问，哪些数据需要保护?
* 如何确保数据收到保护?
* 若当前线程正在操作被保护数据，其他线程可能同时在执行什么代码？
* 当前线程有哪些互斥？
* 其他线程可能持有哪些互斥？
* 当前线程和其他线程上的操作需要服从什么次序？该次序限制如何强制实施？
* 当前线程所读取的数据是否仍然有效？该数据是否有可能被其他线程改动过？
* 当前线程在访问或操作数据，而假定另一个线程可能也在操作数据，如何确保不会发生这种情况？  


### 11.2.2 通过测试定位与并发相关的错误  

&emsp;&emsp;在开发单线程应用程序时，测试应用程序相对简单。原则上，可以找出所有可能的输入数据集(至少找出棘手的测试样例)，并在应用程序中运行它们。如果应用程序产生了正确的行为和输出，我们就知道它适用于给定的输入数据。测试错误状态要比这复杂得多，但思路是一样的 : 设置好初始条件并允许应用程序运行。


&emsp;&emsp;测试多线程代码比较复杂，因为线程间的的调度次序是不确定的，并且每次运行的结果可能都不同。因此，即使使用相同的输入数据运行应用程序，如果代码中存在竞争条件，它也可能在某些时候正常工作，有时则会失败。具有潜在的竞争条件并不意味着代码运行总是失败，只是有时可能会失败。

&emsp;&emsp;再现并发相关的错误是很难的，所以仔细设计测试是值得的。按一般经验，如果代码出现问题，我们就设定尽可能小的范围，为其逐一进行各项测试，只要出错即隔离错误代码。但在并发队列上，更好的测试方式是按并发方式直接压入和弹出数据，而非分别独立运行相关功能的代码。这种方式需要我们在设计代码时深谋远虑，筹划好随后应该如何测试。  

&emsp;&emsp;另外，我们还要进行不含并发测试的操作，以保证存在的错误与并发相关。如果所有代码都在单线程上运行，而错误依旧存在，那就是普通的错误，与并发无关。若并发应用软件在多核/多处理器系统上有错误，但转到单核系统上错误却无端消失，那么，我们肯定遇到了条件竞争，并且它很可能与同步操作或内存次序有关。  

&emsp;&emsp;普通代码的测试主要针对逻辑结构，并发代码则还需另行更多项目，并且测试代码自身的组织结构和测试环境也很重要。如果我们继续思考并发队列，并为其设计测试代码，就必须考虑到各种各样的场景。 

* 单一线程调用push()和pop(),以保证队列的基本功能运行正常 
* 在全空的队列上，A线程调用push(),B线程同时调用pop()
* 在全空的队列上，多个线程并发调用push()
* 在全满的队列上，多个线程并发调用push()
* 在全空的队列上，多个线程并发调用pop()
* 在全满的队列上，多个线程并发调用pop()
* 在半满队列上，多个线程过量并发调用pop(),使得弹出操作因元素不足而无法全部成功 
* 在全空队列上，多个线程并发调用push()，而另一个线程同时并发调用pop()
* 在全满队列上，多个线程并发调用push()，而另一个线程同时并发调用pop()
* 在全空队列上，多个线程并发调用push()，而多个线程同时并发调用pop()
* 在全满队列上，多个线程并发调用push()，而多个线程同时并发调用pop()  

&emsp;&emsp;先考虑上述全部场景和其他情况，在针对测试环境考虑更多因素

* 每项测试中多线程的数目是多少
* 硬件系统所具有的处理器内核是否足够，能否让每个线程独具一个内核
* 应在哪个处理器架构上运行测试
* 我们能否确保系统进行合理调度，使测试中的操作正真实现"同时"和"并发"?

&emsp;&emsp;针对各种特定测试场景的细节，我们还需要考虑更多因素。以上这四个环境因素中，第一个和最后一个因素会影响测试代码的组织结构（第11.2.5节对此进行了说明），而其他两个因素则与所使用的硬件系统有关。要使用的线程数量与正在测试的代码有关，后面讲介绍几种方法编排测试代码的组织结构，以实现恰当的线程调度。在我们研究这些技术之前，让我们先看看如何设计应用程序代码，使其更易于测试。【TODO 组织结构是什么？】

### 11.2.3 设计可测试的代码

&emsp;&emsp;测试多线程代码是困难的，所以要尽自己所能使它更容易。我们能做的最重要的事情之一就是设计可测试性代码。设计可测试的单线程代码文章有很多，而且很多建议仍然适用。通常只要做到以下几点，代码更容易测试 : 

* 每个函数和类的职责清楚明确 
* 函数短小精悍、设计的功能符合需求
* 接受测试的目标代码处于测试环境中，而实施测试的代码和用例可以完全掌握该环境
* 执行特定操作的相关代码应该汇聚在一起，以方便测试，不得分散于整个系统中。
* 在编写代码之前，需要考虑如何测试代码

&emsp;&emsp;上述建议对于多线程代码仍然适用。事实上，多线程代码的可测试性比单线程更需要关注，因为它本身就很难测试。最后一项建议很重要 : 即使做不到"先编写测试用例，再编写功能代码"，至少应该在编写代码前，想清楚该如何测试，比如输入什么，什么情况下会出问题，如何触发代码潜在的错误，等等。  

&emsp;&emsp;若要设计便于测试的并发代码，其中一种较好的方式的就是剔除并发。如果您将代码分解为负责线程之间通信的部分和在单个线程内对通信数据进行操作的部分，那么大大减少了问题。然后，应用程序中仅由一个线程访问并操作数据的部分可以使用普通的单线程技术测试。并发代码负责处理线程间通信，还要保证某些特定数据块每次只由一个线程访问，以上的拆分处理缩小了它所涉及的范围，使原本难以应对的并发测试变得可追踪错误。

&emsp;&emsp;例如，如果应用程序被设计为多线程状态机，就可以将其分成几个部分。只要令每个线程单独处理一个状态的逻辑，分别处理每组可能的输入事件，保证状态转移和相关操作正确，它们就能按单线程方式独立测试，而其他线程则作为驱动，提供输入事件作为测试样例。这样，就能通过专门设计的简单状态逻辑，用多线程的并发方式运行状态机，独立测试其核心代码和分发消息的代码，以保护事件按正确顺序传递给正确的线程。  

&emsp;&emsp;另一种做法是，将代码分为读取共享数据、转换数据、更新共享数据三个部分，由于转换数据的部分都是单线程代码，因此它能以单线程方式测试。这样就将多线程测试转换成了多个单线程的更新和读取。  

&emsp;&emsp;有一个细节需要注意，调用库时可能使用内部变量存储状态，如果多个线程调用相同的库函数那么内部变量将被共享。这可能是一个问题，因为代码访问共享数据并不明显。后面将会介绍这些库函数，到时候我们就会觉得它们格外显眼。我们可以施加保护和同步措施，或将其替换成其他安全并发的函数，让多线程通过它们访问数据。  

&emsp;&emsp;为了便于测试，我们应细心设计多线程代码的数据结构。有些代码要处理并发相关的问题，则要尽可能缩小范围，对非线程安全的库函数调用也要特别注意。同时也要牢记**11.2.1**节设计代码时的问题，并在审核代码时逐一自检查。尽管提出那些问题的本意时审核代码，与测试本身和代码的可测试性没有直接关联，但是只要我们以代码测试位目标，从测试的角度考虑那些问题，就会潜移默化地对我们设计过程产生影响，使代码易于测试。  

&emsp;&emsp;到目前为止，我们学习了怎样设计代码以便于测试，以及如何分离单线程部分和并发部分，而单线程部分仍凭借并发代码与其他线程互动。


### 11.2.4 多线程测试技术

&emsp;&emsp;当我们已经按照前文的方法编写了代码后，如何确保能够复现多线程错误？  

#### 压力测试  

&emsp;&emsp;压力测试的思想是让代码承受压力运行，看看它是否崩溃。这通常意味着要多次运行代码，可能同时运行多个线程。如果有一个bug仅在以特定方式调度线程时才出现，那么代码运行的次数越多，bug出现的可能性就越大。而且代码测试次数越多(每次测试都通过)，我们就越有信心。  

&emsp;&emsp;我们对结果的信心取决于每次测试目标代码的代码量。如果测试就像前文线程安全队列测试的一样，是非常细粒度的，那么这种压力测试可以提高代码的可信度。反之，如果测试的目标代码很大，那么代码可能的调度排列的数量就会增多，即使是十亿次测试运行也不会有太高的可信度。

&emsp;&emsp;压力测试的缺点是会给你带来错误的信心。测试代码可能在当前环境下测试多次也不会出错，但是在其他不同的环境中运行就会出错。最极端的例子就是，导致错误的运行环境只存在特定的系统中，但我们运行测试代码的系统却不是特定系统，所以无法复现错误。除非代码只在与正在测试的系统相同的系统上运行，这样就能保证错误的复现。而某些测试环境由特定的硬件和操作系统组成，有可能令错误无法复现。  

&emsp;&emsp;如果要将应用程序移植到多个目标平台上，那么就有必要从各种操作系统中选出具有代表意义的一个进行专门测试。这就是为什么我在第11.2.2节中将用于测试的处理器架构列为一个考虑因素。

&emsp;&emsp;为了让压力测试有效，避免其增加错误的可信度。这要求我们谨慎思考，确定测试方案，既要选定目标代码的测试单元，又要仔细设计驱动测试的代码和测试环境。我们需要令测试尽量涵盖代码的所有运行路径，并尽可能多地进行线程间交互。不仅如此，我们还需要清楚已经测试过哪些功能，而哪些功能还没测试。 

&emsp;&emsp;尽管压力测试确实给了我们一定程度的自信，但并不能保证找到所有问题。有一种技术，组合模拟测试，如果你有时间将它应用到目标代码和受测软件上，可以保证你找到问题



