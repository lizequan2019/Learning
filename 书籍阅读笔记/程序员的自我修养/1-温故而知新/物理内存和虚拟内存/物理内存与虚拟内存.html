<!DOCTYPE html>
<html>
<head>
    
<meta charset="utf-8">

<title>物理内存与虚拟内存</title>

<style type="text/css">
    p{
    text-indent: 2em; /*em是相对单位,2em即现在一个字大小的两倍*/
    }
 </style>

</head>
<body>
 
<p>在程序运行时,都会被加载到内存中,而使用的内存地址都是操作系统提供的虚拟地址,当要使用数据时,会根据虚拟地址找到实际的物理内存地址,然后找到数据使用。</p>

<br>

<h2>直接为程序分配实际的物理内存地址的问题</h2>

<h3><p>地址空间不隔离</p></h3>

<p><img src="../../../../书籍阅读笔记/程序员的自我修养/1-温故而知新/物理内存和虚拟内存/地址空间不隔离.PNG"></img></p>

<p>为了最大限度的使用内存资源,程序占用的内存地址如上,都是连续的,如上图</p>

<p>如果有恶意的程序,或者错误的程序,它们可以访问到其他程序使用的内存地址,从而进行破坏</p>

<p>所以,为程序直接分配物理内存地址的问题之一就是<font color="ff0000">程序数据不安全</font></p>

<br>

<h3><p>内存使用率低</p></h3>

<p><img src="../../../../书籍阅读笔记/程序员的自我修养/1-温故而知新/物理内存和虚拟内存/内存使用率低.PNG"></img></p>

<p>如上图,当需要程序D加载到内存中运行时,发现内存已经被占满,需要停止一些程序释放出内存空间,因为程序数据需要占用连续的内存空间,所以只好把程序B停止,将数据存入磁盘中</p>

<p>上述提到的操作存在大量数据的换入换出,消耗资源严重,而且内存的使用率还低(上面的情况,有10MB空间就没有使用)</p>

<br>

<h3><p>程序运行的地址不确定</p></h3>

<p>每次将程序在加载到内存中的位置是不同,所以程序数据起始物理内存地址也是不同,那么访问数据和调用函数的跳转到地址也是不固定的,这就涉及到<b>程序的重定位</b>问题</p>
 

<br>
<hr>


<h2>为程序分配虚拟内存地址</h2>

<p>虚拟内存地址故名思意,这个地址是假的,但也不完全是假的,更准确的来说是物理内存地址的映射</p>

<p>为程序分配的虚拟内存地址,对程序来说就是一段起始地址为0的连续地址,程序能访问的地址也被限制到了这一段地址之间</p>

<p><img src="../../../../书籍阅读笔记/程序员的自我修养/1-温故而知新/物理内存和虚拟内存/虚拟内存地址映射.PNG"></img></p>

<p>通过这种方式成功的解决了上面的<b>地址空间不隔离</b>和<b>程序运行的地址不确定</b>的问题</p>

<h3>如何提高内存的使用率</h3>

<p>在上面的描述提到,为了给其他程序腾出内存空间,需要将程序从内存上卸载,将大量数据存到磁盘中。</p>

<p>问题就在这里,程序占用100MB,那么就要进行100MB数据的传输,这样的操作看起来<b>颗粒度</b>很大,严重损耗性能</p>

<p>其实在某个时间段内,程序运行只会频繁的用到一小部分数据,也就是说,其他的大部分数据在这个时间段内是不会被用到的。</p>

<p>所以大神们想到将程序对应的内存块划分为更小的内存块(<b>内存块之间不是连续的</b>),会频繁用到的数据加载到内存中,偶尔使用的数据放到磁盘中,需要时再加载内存中使用</p>

<p><img src="../../../../书籍阅读笔记/程序员的自我修养/1-温故而知新/物理内存和虚拟内存/分页.PNG"></img></p>

<p>这样一来内存使用率就提高了</p>

<pre>
            (1)每个程序在内存中占用的内存数据量少了,程序从内存中卸载的速度就提高了
            (2)内存块划分小了(一个大概是4KB),内存使用的更加灵活,这样内存中的几MB的空间也可以被更好的使用
            (3)内存闲置的空间变多了,可供更多程序使用
</pre>

</body>
</html>