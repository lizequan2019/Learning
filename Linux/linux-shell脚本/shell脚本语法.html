<!DOCTYPE html>
<html>
<head>
    
<meta charset="utf-8">

<title>shell脚本语法</title>

<style type="text/css">
    p{
    text-indent: 2em; /*em是相对单位,2em即现在一个字大小的两倍*/
    }
 </style>

</head>
<body>

<h1>脚本编写规范</h1>
<pre>
            (1)一个变量最好只干一种逻辑,否则容易混淆
            (2)可以使用 sh -n xxx.sh 检测脚本语法
            (3)可以使用 sh -x xxx.sh 跟踪脚本执行
            (4)本篇笔记基于bash解释器学习


</pre>
<hr>
      

<h1>解释器的查看与设置</h1>  
<pre>
            #查看系统当前⽀持哪些shell解释器
                cat  /etc/shells

            #查看系统当前默认的shell解释器
                echo $SHELL

            #修改默认的shell解释器,修改了系统默认shell之后不会⽴即⽣效,之后再次登录系统修改的shell才会⽣效
                chsh -s /bin/sh


</pre>
<hr>


<h1>shell通配符</h1>   
<table border="1px">
    <tr><th>字符</th><th>含义</th><th>实例</th></tr>

    <tr>
      <td>*</td>
      <td>匹配0或多个字符</td>
      <td>a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。</td>
    </tr>

    <tr>
      <td>?</td>
      <td>匹配任意一个字符</td>
      <td>a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。</td>
    </tr>

    <tr>
      <td>[list]</td>
      <td>匹配list中的任意单一字符</td>
      <td>a[xyz]b a与b之间必须也只能有一个字符, 但只能是x或y或z, 如: axb, ayb, azb。</td>
    </tr>

    <tr>
      <td>[!list]</td>
      <td>匹配除list中的任意单一字符</td>
      <td>a[!0-9]b a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。</td>
    </tr>

    <tr>
      <td>[c1-c2]</td>
      <td>匹配c1-c2中的任意单一字符如:[0-9] [a-z]</td>
      <td>a[0-9]b 0与9之间必须也只能有一个字符 如a0b, a1b... a9b。</td>
    </tr>

    <tr>
      <td>\{string1,string2,...\}</td>
      <td>匹配sring1或string2(或更多)其一字符串</td>
      <td>a{abc,xyz,123}b a与b之间只能是abc或xyz或123这三个字符串之一。</td>
    </tr>

</table>
<hr>


<h1>终端打印echo</h1>  
<p>作为终端的输出,下面列举一下使用的技巧</p>
<pre>
            (1) echo输出变量的时候使用${var} , 注意$()是用来输出命令的输出
            (2) echo -e  可以使用转义字符 \n \t
            (3) echo $(#var)  会输出var变量的长度


</pre>
<hr>


<h2><p>echo输出内容的颜色</p></h2>
<pre>
            #字体颜色 : 30m-37m 黑、红、绿、黄、蓝、紫、青、白
            str="kimbo zhang"
            echo -e "\033[30m ${str}\033[0m"      ## 黑色字体
            echo -e "\033[31m ${str}\033[0m"      ## 红色
            echo -e "\033[32m ${str}\033[0m"      ## 绿色
            echo -e "\033[33m ${str}\033[0m"      ## 黄色
            echo -e "\033[34m ${str}\033[0m"      ## 蓝色
            echo -e "\033[35m ${str}\033[0m"      ## 紫色
            echo -e "\033[36m ${str}\033[0m"      ## 青色
            echo -e "\033[37m ${str}\033[0m"      ## 白色
            
            #背景颜色 : 40-47 黑、红、绿、黄、蓝、紫、青、白
            str="kimbo zhang"
            echo -e "\033[41;37m ${str} \033[0m"     ## 红色背景色,白色字体
            echo -e "\033[41;33m ${str} \033[0m"     ## 红底黄字
            echo -e "\033[1;41;33m ${str} \033[0m"   ## 红底黄字 高亮加粗显示
            echo -e "\033[5;41;33m ${str} \033[0m"   ## 红底黄字 字体闪烁显示
            echo -e "\033[47;30m ${str} \033[0m"     ## 白底黑字
            echo -e "\033[40;37m ${str} \033[0m"     ## 黑底白字
            
            
            #控制码(常用): 
            00 取消所有格式 
            04 下划线
            05 闪烁
            07 反显
                    
            #常见的使用格式就是  
            echo -e "\033[背景色;字体色;控制码m ${str} \033[0m" ## 背景色;字体色;控制码 的顺序可以颠倒


</pre>
<hr> 
    

<h1>环境变量的设置</h1>
<p>export命令可以将一个普通变量变成环境变量,当前shell脚本执行的任何程序都会继承这个变量</p>   
<hr> 


<h1>算数</h1>   
<p>基础的整数运算可以使用 $((var1 + var2))这样的符号</p>
<p>当需要更高级的计算时可以使用bc(数学运算的高级工具),在man中学习详细使用方法</p>
<hr>
    

<h1>文件描述符与重定向</h1>
<p>常用的文件描述符<b>stdin=0 stdout=1 stderr=2</b>,文件描述符是与文件输入、输出相关联的整数。它们用来跟踪已打开的文件。</p>
<p>输出重定向是将输出的文本指定到某个文件中,可以覆盖当前文件中的文本或者追加文本</p>
<pre>
            $ echo "This is a sample text 1" > temp.txt    //覆盖
            $ echo "This is sample text 2"  >> temp.txt    //追加

            错误输出 2>  文件   只是将错误输出覆盖到文件
            错误输出 2>> 文件   将错误输出追加到文件


</pre> 
<p>兼容正确输出和错误输出的重定向, 命令 &> (这是覆盖的)或者 &>> (这是追加的)文件,注意这将错误信息和正确信息都放到同一个文件中。</p>
<p>还有一种形式是将正确输出重定向到文件1将错误输出重定向到文件2<b>命令  > 文件1  2> 文件2</b></p>
<hr>


<h1>数组</h1>   
<pre>
            #声明一个空数组
            array_var=()   

            #定义一个数组,注意元素之间不要加逗号
            array_var=(1 2 3 4 5 6)  

            #下面这样单独定义也可以
            array_var[0]="test1"
            array_var[1]="test2"
            array_var[2]="test3"
            array_var[3]="test4"
            array_var[4]="test5"
            array_var[5]="test6"

            #还有一点和C语言中数组不太一样的是,shell中的数组是可以不连续的,可以在上面定义的基础上定义array_var[100]
            array_var[0]="test1"
            array_var[1]="test2"
            array_var[2]="test3"
            array_var[3]="test4"
            array_var[4]="test5"
            array_var[5]="test6"
            array_var[100]="test100"

            #打印出特定索引的数组元素内容
            echo ${array_var[0]}    

            #以清单形式打印出数组中的所有值 * 也可以用 @ 代替
            echo ${array_var[*]}  

            #打印数组长度(即数组中元素的个数)
            echo ${#array_var[*]} 

            #列出数组的索引
            echo ${!array_var[*]}
</pre>
<hr>


<h1>函数及其参数</h1>
<p>shell脚本同样支持函数的定义,有以下两种方法</p>
<p>在使用变量的时候,自定义函数中的变量最好使用<b>local</b>修饰,变成局部变量</p>
<pre>
            #函数的声明
                function fname()
                {
                    statements
                    return 0      #一般返回0都是正确退出状态  
                }
            
                fname()
                {
                    statements
                    return 0
                }
            
            #函数的使用
                fname xxx # xxx是参数


</pre>
<p>接着说一下输入参数,shell脚本的输入参数和函数的输入参数是一样的。在脚本和函数的后面直接跟参数即可。</p>
<table border="1px">
    <tr>
      <th>参数</th>
      <th>解释</th>
    </tr>
    <tr>
      <td>$n</td>
      <td>传递给脚本或函数的参数。n是一个数字,表示第几个参数。例如,第一个参数是$1,第二个参数是$2。参数在10以及10以上则需要用大括号${10},$0是命令本身</td>
    </tr>
    <tr>
      <td>$()</td>
      <td>$()是用来输出命令的结果</td>
    </tr>
    <tr>
      <td>${}</td>
      <td>输出变量的时候使用${变量}</td>
    </tr>
    <tr>
      <td>#$</td>
      <td>此变量代表命令行中所有参数的个数,不包括命令本身</td>
    </tr>
    <tr>
      <td>$*</td>
      <td>此变量代表传递给脚本或函数的所有参数,会把所有参数当做一个整体,例如for循环传递参数时用 $* 就不可以</td>
    </tr>
    <tr>
      <td>$@</td>
      <td>此变量代表传递给脚本或函数的所有参数,但每个参数还是独立的可以单独使用</td>
    </tr>
    <tr>
      <td>?</td>
      <td>最近一次命令或自定义函数的执行情况</td>
    </tr>
 </table>
 <hr>
  

<h1>多命令执行与管道符</h1>
<table border="1px">
    <tr>
      <th>符号</th>
      <th>含义</th>
    </tr>
    <tr>
      <td>;</td>
      <td>命令之间没有关系</td>
    </tr>
    <tr>
      <td>&&</td>
      <td>当前一个命令正确执行,后面的命令才会执行,前面命令错误,后面命令不执行</td>
    </tr>
    <tr>
      <td>||</td>
      <td>当前一个命令正确执行,后面命令不执行,前面命令错误,后面命令执行</td>
    </tr>
    <tr>
      <td>| (管道符)</td>
      <td>命令1 | 命令2  命令1的正确输出作为命令2的操作对象</td>
    </tr>
</table>
<hr>


<h1>字段分割符</h1>
<p>内部字段分隔符(Internal Field Separator,IFS)是shell脚本编程中的一个重要概念。</p>
<p>内部字段分隔符是用于特定用途的定界符。 IFS是存储定界符的环境变量(默认是空白字符)。它是当前shell环境使用的默认定界字符串。</p>
<pre>
            #!/bin/bash

            data="name,sex,rollno,location"

            oldIFS=$IFS

            IFS=,               #给环境变量IFS赋值设置分隔符号为,

            for item in $data;   
            do
                echo Item: $item
            done

            IFS=$oldIFS


</pre>
<hr>


<h1>循环</h1>
<pre>
            #在循环这个部分我先学习for循环和while循环两个
            
            #for循环有两种模式
            for 变量 in x  #in 后面可以是一个列表 {1..100} {a..z}这样的,也可以是一个数组 ${array[@]}
            do
                程序
            done
            
            
            for((i=1;i<=100;i=i+1))
            do
                程序
            done
            
            
            #while 循环
            while [ x ]
            do
                程序
            done
            ```
            
            ## if语句
            
            ```shell
            
            #[ ]是符合POSIX标准的测试语句,兼容性更强,几乎可以运行在所有的Shell解释器中  
            #[[ ]]仅可运行在特定的几个Shell解释器中(如Bash等)   这要学习[[]]格式的
            
            
            #这里需要注意的格式if和[[]]要有空格,[[]]中的内容两端要有空格
            #单分支if语句
                if [[ x ]];then
                程序
                fi
            
            
                if [[ x ]]
                then
                程序
                fi
            
            
            #双分支if语句
                if [[ ]]
                then
                    ...
                else
                    ...
                fi
            
            
            #多分支if语句
                if [[]]
                then
                    ...
                elif [[]]
                then
                    ...
                else
                fi
            
            #与或条件
                if [[]] || [[]]
            
                if [[]] && [[]]


</pre>
<hr>


<h1>数字之间的比较</h1>
<table border="1px">
    <tr>
      <th>关系运算符</th>
      <th>说明</th>
      <th>举例</th>
    </tr>
    <tr>
      <td>-eq (==)</td>
      <td>检测两个数是否相等,相等返回true</td>
      <td>[ $a -eq $b ] 返回 true。</td>
    </tr>
    <tr>
      <td>-ne (!=)</td>
      <td>检测两个数是否相等,不相等返回true</td>
      <td>[ $a -ne $b ] 返回 true。</td>
    </tr>
    <tr>
      <td>-gt (>)</td>
      <td>检测左边的数是否大于右边的,如果是,则返回true</td>
      <td>[ $a -gt $b ] 返回 false。</td>
    </tr>
    <tr>
      <td>-lt (<)</td>
      <td>检测左边的数是否小于右边的,如果是,则返回true</td>
      <td>[ $a -lt $b ] 返回 true。</td>
    </tr>
    <tr>
      <td>-ge (>=)</td>
      <td>检测左边的数是否大等于右边的,如果是,则返回true</td>
      <td>[ $a -ge $b ] 返回 false。</td>
    </tr>
    <tr>
      <td>-le (<=)</td>
      <td>检测左边的数是否小于等于右边的,如果是,则返回true</td>
      <td>[ $a -le $b ] 返回 true。</td>
    </tr>
</table>
<hr>
  
    
<h1>字符串运算符</h1>
<table border="1px">
    <tr>
      <th>字符串运算符</th>
      <th>说明</th>
      <th>举例</th>
    </tr>
    <tr>
      <td>==</td>
      <td>检测两个字符串是否相等,相等返回true</td>
      <td>[[ $a == $b ]]</td>
    </tr>
    <tr>
      <td>!=</td>
      <td>检测两个字符串是否相等,不相等返回true</td>
      <td>[[ $a != $b ]] 返回 true</td>
    </tr>
    <tr>
      <td>-z</td>
      <td>(zero)检测字符串长度是否为0,为0返回true</td>
      <td>[[ -z $a ]] 返回 false</td>
    </tr>
    <tr>
      <td>-n</td>
      <td>(nonzero)检测字符串长度是否为0,不为0返回true</td>
      <td>[[ -z $a ]] 返回 true</td>
    </tr>
</table>
<hr>
  

<h1>多重条件判断</h1>
<table border="1px">
    <tr>
      <th>布尔运算符</th>
      <th>说明</th>
      <th>举例</th>
    </tr>
    <tr>
      <td>!</td>
      <td>非运算,表达式为true则返回false,否则返回true</td>
      <td>[ ! false ] 返回 true。</td>
    </tr>
    <tr>
      <td>-o</td>
      <td>或运算,有一个表达式为true则返回true</td>
      <td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
    </tr>
    <tr>
      <td>-a</td>
      <td>与运算.两个表达式都为true才返回true</td>
      <td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
    </tr>
</table>
<hr>
  

<h1>shell脚本的退出</h1>
<p>使用exit x就可以退出脚本,x代表的是数字。</p>

<br>
<br>

</body>
</html>



