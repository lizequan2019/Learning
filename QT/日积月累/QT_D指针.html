<!DOCTYPE html>
<html>
<head>
    
<meta charset="utf-8">

<title>Qt_D指针</title>

<style type="text/css">
    p{
    text-indent: 2em; /*em是相对单位,2em即现在一个字大小的两倍*/
    }
 </style>

</head>
<body>
 
<h1>Q_D语法解读</h1>

<p>D指针的宏定义为 <b>#define Q_D(Class) Class##Private * const d = d_func()</b></p>

<pre>
            #define                
            Q_D                          宏的名称
            (Class)                      宏的参数
            Class                        参数的使用
            ##                           是一个连接符,用于在宏展开时将两个标记连接成一个标记。此时将传入的Class和Private连接成一个新ClassPrivate标记
            Private * const d = d_func() 宏展开后的内容

</pre>

<hr>

<h1>PImpl(Pointer to Implementation)技巧</h1>

<p>如上举例,当入参是QFile时,展开结果为QFilePrivate * const d = d_func(),QFilePrivate是什么?和QFile是什么关系?</p>

<p>这里需要简单的介绍一下PImpl</p>

<pre>
            Pointer to Implementation(简称PImpl)是一种C++设计模式，也称为"编译期实现"或"指向实现的指针"

            用于将类的实现细节与其公共接口分离开来。其<b>核心思想是通过一个指向类的实现的指针来隐藏类的实现细节，</b>从而提高类的封装性和安全性。

            这种编程技巧将类的实现细节从对象表示中移除，放到一个分离的类中，并以一个不透明的指针进行访问。 此技巧用于构造拥有稳定ABI的C++ 库接口，及减少编译时依赖。

</pre>

<p>也就是说QFilePrivate是QFile的细节实现类,那么QFilePrivate * const d = d_func()就是获取了细节实现类的指针,然后进行功能调用</p>

<p>这里注意QFilePrivate * const d是一个常量指针,此指针指向的地址不可更改,但是可以修改存储的值</p>

<pre>
            QFile::QFile(const QString &name) : QFileDevice(*new QFilePrivate, 0)
            {
                Q_D(QFile);
                d->fileName = name;
            }
</pre>

<p>关于PImpl更详细的说明可以参考csdn博客<a href="https://blog.csdn.net/Appleeatingboy/article/details/129261011?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171616858116800211551832%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171616858116800211551832&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129261011-null-null.142^v100^pc_search_result_base9&utm_term=Pointer%20to%20Implementation&spm=1018.2226.3001.4187">【网络链接】PImpl(Pointer to Implementation)指向实现的指针</a></p>

<hr>

<h1>d_func()语法解读</h1>

<p>d_func()是在宏定义Q_DECLARE_PRIVATE中出现的,QFile类中会这么表示Q_DECLARE_PRIVATE(QFile),这样上面的Q_D(QFile)就可以使用了</p>

<pre>
            #define Q_DECLARE_PRIVATE(Class) \

            inline Class##Private* d_func() \
            { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<Class##Private *>(qGetPtrHelper(d_ptr));) } \
                
            inline const Class##Private* d_func() const \
            { Q_CAST_IGNORE_ALIGN(return reinterpret_cast<const Class##Private *>(qGetPtrHelper(d_ptr));) } \

            friend class Class##Private;

</pre>

<p>Q_DECLARE_PRIVATE宏定义展开后,可以看到<b>d_func()</b>分为两个版本,d_func()用于非const成员函数,d_func() const用于const成员函数</p>

<p>这里找两个QFile中的函数展示一下,无关宏定义的部分删除</p>

<pre>
            QString QFile::fileName() const
            {
                Q_D(const QFile);
            }
            展开流程  Q_D(const QFile) => const QFilePrivate * const d = d_func()



            void QFile::setFileName(const QString &name)
            {
                Q_D(QFile);
            }
            展开流程  Q_D(QFile) => QFilePrivate * const d = d_func()

</pre>

<p>宏定义展开后</p>

<pre>
            QString QFile::fileName() const
            {
                const QFilePrivate * const d = d_func();
            }

            void QFile::setFileName(const QString &name)
            {
                QFilePrivate * const d = d_func();
            }
</pre>



</body>
</html>