
> 参考博客 https://www.cnblogs.com/mavaL/articles/2515381.html

&emsp;&emsp;这篇博客还没有完全的消化，模板那部分先不看了。大致的写一下作者的思路。

&emsp;&emsp;作者举例一个增加好友的例子，在AddFriend()函数中有两个操作，一个将好友信息增加到数据库中，另一个操作是将好友信息增加到一个容器中(应该是为了方便其他地方使用)。这两个操作都有可能抛出异常，当一个操作抛出异常时，另一个操作则不会被操作，然后函数结束。作者从此处开始展开，举了几个我们一般用到的异常处理方法，比如直接用try catch()处理每个操作，或者使用RAII为每个操作创建一个类，但是经过逐步分析发现这些方法是可以完成资源回收，但是很麻烦，最终会导致程序员放弃处理异常。  

&emsp;&emsp;这时作者提出了一个想法，依旧是设计一个类，但是此类会执行你传入的一个操作(一般就是一个函数)，这个操作就是回收资源。如下所示。  

&emsp;&emsp;现在分析一下，如果`friends_.push_back`操作出现异常则信息也不会加入内存中，函数也会直接结束，不需要进行回收资源操作。如果`pDB_->AddFriend`执行出现异常，那么函数也会结束但是会执行`ScopeGuard`的析构函数，析构函数中就会执行上面传入的回收资源操作。

```c
    void User::AddFriend(User& newFriend){
        friends_.push_back(&newFriend); //将朋友信息加入到内存中

        // ScopeGuard 就是作者设计的类    MakeObjGuard是一个辅助函数
        ScopeGuard guard = MakeObjGuard(friends_, &UserCont::pop_back);

        pDB_->AddFriend(GetName(), newFriend.GetName()); //将朋友信息加入到数据库中

        guard.Dismiss(); //设置ScopeGuard对象是否要执行回收资源操作
    }
```

### 第一版实现

&emsp;&emsp;按照博客中的描述，我首先实现一下最基本的操作。  

&emsp;&emsp;vec变量先`psuh_back`四个元素，然后执行`test()`(此函数中也会`push_back()`一个元素，但是会抛出异常)，最后再查询一下vec元素的个数，发现vec中依旧是四个元素。

&emsp;&emsp;<font color=#ff0000>思考</font>，其实我刚开始还在想，抛出异常后，程序不就自动终止了，那还需要做撤回这些复杂的操作吗？但是仔细思考，连接数据库出现异常结果导致整个程序终止退出，这对用户太不友好了，所以还是需要捕获住异常，让程序正常的运行。**出现异常后程序还要继续运行，那么就需要考虑发生异常时需要回收的资源。**

```
执行结果:

    捕获到异常
    1  2  3  4
```

```c
        #include <iostream>
        #include <vector>
        using namespace std;

        class ScopeGuardBase {//自定义实现  ScopeGuardBase
            public:

                ScopeGuardBase(vector<int> & _vec, void(*fun)(vector<int> &)):m_vec(_vec),m_fun(fun),blIsundo(true){//m_vec是引用变量 必须使用初始化列表
                }

                virtual ~ScopeGuardBase(){//析构函数中根据标志位判断是否执行回撤函数
                    try{
                     //catch(...)块什么事也不做。这可不是随手写的，这在异常处理的领域中是很基本的：如果回撤操作也失败了，那么你几乎没有什么事情可以做了。
                     //你尝试恢复，但是不管恢复操作是否成功，你都应该继续下去。
                        if(blIsundo){          
                            m_fun(m_vec);
                        }
                    }
                    catch(...){
                    }
                }

                void SetIsDo(){//设置不执行回撤函数
                    blIsundo = false;
                }

            private:
                bool blIsundo;               //是否撤销操作标志位  true表示撤销  false表示不撤销  默认是撤销
                vector<int> & m_vec;         //要操作的对象
                void (*m_fun)(vector<int> &);//回撤函数
        };

        //回撤函数
        void pushback(vector<int> & vec){
                vec.pop_back();
        }

        //测试函数
        void  test(vector<int> & _vec){
            _vec.push_back(5);
            ScopeGuardBase scop(_vec,pushback);
            throw "123"; //抛出一个异常，只是为了执行回撤函数
            scop.SetIsDo();
        }

        int main(){
            vector<int> vec;
            vec.push_back(1);
            vec.push_back(2);
            vec.push_back(3);
            vec.push_back(4);

            try {//必须要捕获异常否则程序会被终止
                test(vec);
            } 
            catch (...) {
                cout <<"捕获到异常"<<endl;
            }
            
            for(int i = 0; i < vec.size(); ++i){//输出vec的元素
                cout <<" "<<vec[i]<<" ";
            }

            return 0;
        }
```

### 第二版实现(调用类成员函数)

&emsp;&emsp;除了上面调用一个普通函数外，作者又扩展了可以调用类成员函数进行回撤操作。我也模拟了一下如何调用。

```c
        执行fun()
        捕获到异常
```

```c
        #include <iostream>
        #include <vector>
        using namespace std;

        class A{
            public:
                A(){
                }

                void fun(){
                    cout <<"执行fun()"<<endl;
                }
        };

        class ScopeGuardBase {
            public:
                /*
                    这里说一下入参  第一个参数是一个类对象的引用
                                  第二个参数是类成员函数的函数指针
                 */
                ScopeGuardBase(A & _vec, void(A::*fun)()):m_vec(_vec),m_fun(fun),blIsundo(true){

                }

                virtual ~ScopeGuardBase(){//析构函数中根据标志位判断是否执行回撤函数

                    try{
                        if(blIsundo){         
                            //类成员对象调用对应成员函数变量 
                            (m_vec.*m_fun)(); 
                        }
                    }
                    catch(...){

                    }
                }

                void SetIsDo(){
                ScopeGuardBaseate:
                bool blIsundo;     //是否撤销操作标志位  true表示撤销  false表示不撤销  默认是撤销
                A & m_vec;         //要操作的对象
                void (A::*m_fun)();//回撤函数
        };


        //测试函数
        void  test(){
            A a;
            ScopeGuardBase scop(a,&A::fun);
            throw "123"; //抛出一个异常，只是为了执行回撤函数
            scop.SetIsDo();
        }

        int main(){
            try {//必须要捕获异常否则程序会被终止
                test();
            } 
            catch (...) {
                cout <<"捕获到异常"<<endl;
            }
            return 0;
        }
```



### 第三版实现(模板化 基于第一版)

&emsp;&emsp;我觉得这一版就挺好，直接构造子类对象用就行了

```c
        #include <iostream>
        #include <vector>
        using namespace std;

        //模板化基类
        template <class OBJ, class FUN>
        class ScopeGuardBase {//自定义实现  ScopeGuardBase
            protected:
                ScopeGuardBase(OBJ & _vec, FUN _fun):m_vec(_vec),m_fun(_fun),blIsundo(true){//m_vec是引用变量 必须使用初始化列表

                }

                ~ScopeGuardBase(){//析构函数中根据标志位判断是否执行回撤函数
                      cout<<"基类不实现"<<endl;
                }

            public:
                void SetIsDo(){//设置不执行回撤函数
                    blIsundo = false;
                }

            protected:
                bool blIsundo;    //是否撤销操作标志位  true表示撤销  false表示不撤销  默认是撤销
                OBJ & m_vec;      //要操作的对象
                FUN m_fun;        //回撤函数
        };

        //模板化子类
        template <class OBJ, class FUN>
        class  ScopeGuardDrive : public ScopeGuardBase<OBJ,FUN>
        {
            public:
                ScopeGuardDrive(OBJ & _vec, FUN _fun):ScopeGuardBase<OBJ,FUN>(_vec, _fun){//m_vec是引用变量 必须使用初始化列表

                }

                ~ScopeGuardDrive(){

                    cout<<"子类实现"<<endl;
                    try
                    {
                     //catch(...)块什么事也不做。这可不是随手写的，这在异常处理的领域中是很基本的：如果回撤操作也失败了，那么你几乎没有什么事情可以做了。
                     //你尝试恢复，但是不管恢复操作是否成功，你都应该继续下去。
                        if(this->blIsundo){          
                            this->m_fun(this->m_vec);
                        }
                    }
                    catch(...){

                    }
                }
        };

        //回撤函数
        void pushback(vector<int> & vec){
                vec.pop_back();
        }

        //回撤操作的函数指针类型
        typedef void (*fun)(vector<int> &);

        //测试函数
        void  test(vector<int> & _vec){
            _vec.push_back(5);
            ScopeGuardDrive<vector<int>, fun> scop(_vec,pushback);
            throw "123"; //抛出一个异常，只是为了执行回撤函数
            scop.SetIsDo();
        }

        int main(){
            vector<int> vec;

            vec.push_back(1);
            vec.push_back(2);
            vec.push_back(3);
            vec.push_back(4);

            try {//必须要捕获异常否则程序会被终止
                test(vec);
            } 
            catch (...) {
                cout <<"捕获到异常"<<endl;
            }
            
            for(int i = 0; i < vec.size(); ++i){//输出vec的元素
                cout <<" "<<vec[i]<<" ";
            }

            return 0;
        }
```


### 第四版实现(取消virtual)

&emsp;&emsp;按照作者的思想，使用引用接收临时变量，用这个机制替代虚析构机制。我觉得这个机制了解一下即可，我的程序还没有极致到要节约这点性能。

> C++中保证如果临时对象被初始化给一个引用(指针好像不行)，那么临时变量的生命期和该引用的生命期一样。  

> **C++保证临时对象一定会被正确的析构(似乎只有析构函数可以这么用)**，这个正确的析构正是我们利用的地方，编译器知道(或者说记住了)该临时对象的实际类型，所以会正确的调用该对象的析构函数。想一下如果不是临时对象，而我们通过基类的引用去引用一个派生类对象，个人认为在这种情况下，编译器是不会记住该对象的动态类型的，而是通过虚拟机制来找到正确的析构函数，所以如果基类的析构函数不声明为virtual的话，只有基类的析构函数会被调用。

```
执行结果

        基类构造函数
        子类构造函数
        子类析构函数
        ====blIsundo is true=====
        基类析构函数                 //从这往上可以看出，只进行了子类对象的构造、析构，并且引用变量变成了子类类型，因为发生了异常，所以调用了子类析构函数中的回撤操作
        捕获到异常
        1  2  3  4 


        比较=============================== //下面比较下不使用引用接收子类临时对象，直接用基类对象接收子类临时对象

        //A B是子类临时对象构造 D E是子类临时对象析构  C是基类拷贝构造 F是基类对象析构
        //可以发现没有virtual加持，单纯使用基类对象接收子类临时对象，引用变量实际还是基类类型 在E处调用SetIsDo()，没有发生异常但依旧执行了回撤操作(说明没有调用子类的SetIsDo())
        //这是因为是基类对象调用的SetIsDo()和子类临时对象没关系

        基类构造函数  【A】
        子类构造函数  【B】
        基类拷贝构造函数  【C】
        子类析构函数     【D】
        ====blIsundo is true===== 【E】
        基类析构函数 【E】
        基类析构函数 【F】
```

```c
        #include <iostream>
        #include <vector>
        using namespace std;

        class ScopeGuardBase {//自定义实现  ScopeGuardBase
            public:

                ScopeGuardBase():blIsundo(true){
                    cout<<"基类构造函数"<<endl;
                }

                ScopeGuardBase(const ScopeGuardBase & _b){
                    cout<<"基类拷贝构造函数"<<endl;
                    this->blIsundo = _b.blIsundo;
                }

                ~ScopeGuardBase(){
                    cout <<"基类析构函数"<<endl;
                }

            public:
                void SetIsDo() const {//设置不执行回撤函数
                    blIsundo = false;
                }

            protected:
                mutable bool blIsundo;//是否撤销操作标志位  true表示撤销  false表示不撤销  默认是撤销
        };

        //模板化子类
        template <class OBJ, class FUN>
        class  ScopeGuardDrive : public ScopeGuardBase{
            public:
                ScopeGuardDrive(OBJ & _vec, FUN _fun):m_vec(_vec),m_fun(_fun){//m_vec是引用变量 必须使用初始化列表
                    cout<<"子类构造函数"<<endl;
                }

                ~ScopeGuardDrive(){
                    cout<<"子类析构函数"<<endl;
                    try{。
                        if(this->blIsundo){  
                            cout<<"====blIsundo is true====="<<endl;        
                            this->m_fun(this->m_vec);
                        }
                    }
                    catch(...){
                        //catch(...)块什么事也不做。这可不是随手写的，这在异常处理的领域中是很基本的：如果回撤操作也失败了，那么你几乎没有什么事情可以做了。
                        //你尝试恢复，但是不管恢复操作是否成功，你都应该继续下去
                    }
                }

            private:
                OBJ & m_vec;      //要操作的对象
                FUN m_fun;        //回撤函数
        };

        typedef const ScopeGuardBase & ScopeGuard;//【重点 使用引用】

        template <class OBJ, class FUN>
        ScopeGuardDrive<OBJ, FUN> MakeGuard(OBJ & _obj, FUN  _fun){
            return ScopeGuardDrive<OBJ, FUN>(_obj,_fun);
        }

        //回撤函数
        void pushback(vector<int> & vec){
                vec.pop_back();
        }

        //回撤操作的函数指针类型
        typedef void (*fun)(vector<int> &);

        //测试函数
        void  test(vector<int> & _vec){
            _vec.push_back(5);
            ScopeGuard scop = MakeGuard<vector<int>, fun> (_vec,pushback);
            throw "123"; //抛出一个异常，只是为了执行回撤函数
            scop.SetIsDo();
        }

        int main(){
            vector<int> vec;
            vec.push_back(1);
            vec.push_back(2);
            vec.push_back(3);
            vec.push_back(4);

            try {//必须要捕获异常否则程序会被终止
                test(vec);
            } 
            catch (...) {
                cout <<"捕获到异常"<<endl;
            }
            
            for(int i = 0; i < vec.size(); ++i){//输出vec的元素
                cout <<" "<<vec[i]<<" ";
            }

            cout<<""<<endl;
            cout <<"比较==============================="<<endl;
            ScopeGuardBase b =  MakeGuard<vector<int>, fun> (vec,pushback);
            b.SetIsDo();

            return 0;
        }
```
