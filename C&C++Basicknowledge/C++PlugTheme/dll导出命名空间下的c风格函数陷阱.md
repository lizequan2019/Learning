[TOC]

## 问题介绍

&emsp;&emsp;写在2022-9-3，这是一个经典的问题，前一段时间我还以为自己验证充分并找到了问题解决方法，最近发现自己当时是验证错误的，感到了自己的愚蠢，特此在这里记录并警醒自己。为了防止链接失效，我特地把博客原文抄下来了

> 参考博客  http://t.zoukankan.com/feihe0755-p-6275263.html  


## 动态库导出命名空间下的c风格函数陷阱

&emsp;&emsp;有一种情况，编译器链接器都无法识别。那就是两个dll之间有重名的导出函数。那么调用重名函数时使用的是哪个库的？**先链接哪个库，就调用谁。**

### 验证说法

&emsp;&emsp;针对上面提到的问题，我进行了验证,验证角度分为`纯C代码`和`C/C++混合使用代码`，再加上调用导出函数分为`静态调用`和`动态调用`，所以一共有四种情况我都进行了验证,由于验证代码内容过多，所以放到了其他目录。

### C/C++混合代码

#### 静态加载

&emsp;&emsp;在`plubic.h`文件中我设置了宏定义，可以启用或者不启用`命名空间`和启用或不启用`extern C`。验证代码参见[静态加载](./dll-problem-wirhCstyle/C-C++代码/静态加载/main.cpp)。

|情况分类|结果|启用命名空间|启用extern C|
|----|----|----|----|
|1|x 和情况4相同|启用|启用|
|2|x 和情况4相同|不启用|启用|
|3|✓ 运行正确，调用有区分|启用|不启用|
|4|x 编译时先链接，运行时就调用谁|不启用|不启用|

&emsp;&emsp;情况1因为命名空间与extern “C”组合在一起时，生成的函数代码其实是C风格的，没有命名空间修饰。这是因为C风格里函数里没有命名空间这一概念，所以命名空间自动会被链接器忽略。情况2和情况4是因为没有启用命名空间导致。


#### 动态加载

&emsp;&emsp;验证代码 [动态加载](./dll-problem-wirhCstyle/C-C++代码/动态加载/main.cpp)

|情况分类|结果|启用命名空间|启用extern C|
|----|----|----|----|
|1|✓ 运行正确，调用有区分|启用|启用|
|2|✓ 和情况1相同|不启用|启用|
|3|x 编译正常，运行直接段错误|启用|不启用|
|4|x 和情况3相同|不启用|不启用|

&emsp;&emsp;情况3和情况4是因为没有启用`extern C`导致的，原因是使用`dlsym`函数解析导出函数，这个函数只能解析C语言的导出符号，面对C++`Name Mangling(名字混淆)`方式的导出符号，`dlsym`解析不出来。这里还有一个方法即不是使用`extern C`也可以让`dlsym`能解析出来的方法就是查看动态库对应函数的实际符号名称，然后硬编码都main.cpp中。所以，通过这种解决方法，我们再测试一下情况3和4。

|情况分类|结果|启用命名空间|启用extern C|
|----|----|----|----|
|3|✓ 编译正常，调用有区分，导出符号不同|启用|不启用|
|4|✓ 编译正常，调用有区分，导出符号相同|不启用|不启用|




### 纯C代码

#### 静态加载

&emsp;&emsp;这种情况下，不必使用`extern "C"`了，也不能使用`命名空间`,因为C语言不支持此语法，此时只能修改各个库中的导出函数的名字来区别。**否则执行结果依赖库文件调用顺序**。验证代码参见[静态加载](./dll-problem-wirhCstyle/C代码/静态加载/main.c)。



#### 动态加载

&emsp;&emsp;这种情况下，不必使用`extern "C"`了，也不能使用`命名空间`,因为C语言不支持此语法，此时编译正常，运行结果也正常，调用有区分。验证代码参见[动态加载](./dll-problem-wirhCstyle/C代码/动态加载/main.c)。



### 验证问题总结  

&emsp;经过以上验证，发现动态库之间导出函数重名对动态绑定方式没有影响，对静态绑定有影响，而在静态绑定中又分为纯C代码和C/C++混合代码，对于纯C代码,需要修改函数名使得不再重名,而对于C/C++代码则在仅使用命名空间且不使用"extern C"才能进行区分。

&emsp;&emsp;这样看来，动态库的动态绑定还是很好用的

