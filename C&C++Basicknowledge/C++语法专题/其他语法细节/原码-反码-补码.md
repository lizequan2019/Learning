  
  
### 这里作为一个计算机基础知识来记录。

&emsp;&emsp;这里举例 **int a** = 130 和 **int b** = -130 数字，**注意我这里是加粗了类型，int类型是4字节 ，所以在补0的时候要补满32位**


### 三码转换

```
    原码

         130    0000 0000 0000 0000 0000 0000 1000 0010(原码)
        -130    1000 0000 0000 0000 0000 0000 1000 0010(原码)
        
    反码   负数在原码的基础上除符号位之外，全部取反。  
           正数的反码和原码一样

         130    0000 0000 0000 0000 0000 0000 1000 0010(反码)
        -130    1111 1111 1111 1111 1111 1111 0111 1101(反码)

    补码   负数 在反码的基础上+1      正数的补码和原码一样
    
         130    0000 0000 0000 0000 0000 0000 1000 0010(补码)
        -130    1111 1111 1111 1111 1111 1111 0111 1110(补码)
```


### 程序中的使用

&emsp;&emsp;在计算机程序运算时，都是使用的数值的补码进行计算，用一下代码可以查询 -130 对应的16进制数
```c++
        #include <iostream>
        using namespace std;
        int main()
        {
        int i = -130;
        printf("i = %x",i);
        }
```
&emsp;&emsp;结果为 i = ffffff7e (1111 1111 1111 1111 1111 1111 0111 1110)
 
 
 
 
### 注意事项
&emsp;&emsp;C语言中的整数自动转换原则。当**表达式中存在有符号类型和无符号类型时,所有的操作数都自动转换为无符号类型**。自动转换的时机应该是操作数转换为补码的时候。

```c++
    //这种不同类型的比较会出现与原意不同的结果
    #include <iostream>
    using namespace std;
    int main()
    {
        int x = -1;
        unsigned int y = 2;
        
        if(x > y) {   //x = ffffffff   y = 00000002   16进制
            cout << "x is greater";   //输出这句话
        } else {
            cout << "y is greater";
        }
    }
```