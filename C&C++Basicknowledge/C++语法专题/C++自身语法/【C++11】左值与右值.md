[TOC]

### 区分左值与右值

#### 左值

&emsp;&emsp;可以放在等号的左边，可以取地址，可以具名的称为左值。例如

* 具体的变量名
* 返回左值引用的函数调用
* 变量的前置自增/前置自减，++i
* 赋值运算
* 复合运算符
* 解引用

#### 右值

&emsp;&emsp;**只能**放在等号右边的，不能取地址，不具名为右值。

---

### 深入理解右值

#### 纯右值 

* 返回非引用类型的函数调用
* 变量的后置自增/前置自减，i++
* 算数表达式 a+b
* 逻辑表达式 a && b
* 比较表达式 a > b


#### 将亡值

&emsp;&emsp;c++新增的语法，与右值引用(移动语义)息息相关。可以**触发移动构造和移动赋值函数进行资源转移，完成转移后可以自动析构的右值称为将亡值**。

<details>
<summary> 纯右值与将亡值示例代码 </summary>

```c++
    #include <iostream>
    using namespace std;

    //测试将亡值解开注释  测试纯右值注释
    #define DYINGVALUE 1    

    class A{
        private:
                int aa;
        public:

                A(){
                    cout<<"构造函数"<<endl;
                }

                A(const A & a){
                    cout<<"拷贝构造函数"<<endl;
                    this->aa = a.aa;
                }

                A &operator=(const A & a){
                    this->aa = a.aa;
                    cout << "普通赋值函数" << endl;

                    return *this;
                }
    #ifdef DYINGVALUE
                A(A && a) {
                    this->aa = a.aa;
                    cout << "移动构造函数" << endl;
                }

                A &operator=(A && a){
                    this->aa = a.aa;
                    cout << "移动赋值函数" << endl;

                    return *this;
                }
    #endif
                ~A(){
                    cout<<"析构函数"<<endl;
                }
    };

    A CreateA(){
        A a;
        return a;
    }

    int main(){

        A a1  = CreateA();
        cout<<"========"<<endl;

        A a2;
        cout<<"========"<<endl;

        a2 = CreateA();
        cout<<"========"<<endl;
        
        return 0;
    }

    /*
    使用 g++ main.cpp -std=c++11 -fno-elide-constructors 编译，显示被编译器优化的执行步骤

    测试将亡值结果
                    构造函数
                    移动构造函数
                    析构函数
                    移动构造函数  <==使用移动构造函数转移资源，然后析构
                    析构函数
                    ========
                    构造函数
                    ========
                    构造函数
                    移动构造函数
                    析构函数
                    移动赋值函数  <==使用移动赋值函数转移资源，然后析构
                    析构函数
                    ========
                    析构函数
                    析构函数

    测试纯右值结果
                    构造函数
                    拷贝构造函数
                    析构函数
                    拷贝构造函数
                    析构函数
                    ========
                    构造函数
                    ========
                    构造函数
                    拷贝构造函数
                    析构函数
                    普通赋值函数
                    析构函数
                    ========
                    析构函数
                    析构函数
    */
```
</details>

---

### 已经了解的引用知识(来自 c++ primer plus)

&emsp;&emsp;这里我首先总结一些已知的知识点。

* 引用变量声明时必须要初始化，并且**赋值符号的右边必须是左值，且类型必须完全匹配**
* 引用变量分为常量引用和非常量引用，常量引用在初始化后就无法再更改了

&emsp;&emsp;这里再讨论一下`常量引用(const type &)`做为函数形参情况，这一块很有意思，上面已经提到过，引用赋值需要左值，但是现在`const引用`作为形参时却不一样。

<details>

<summary> 常量引用为形参示例代码 </summary>

```c++

    #include <iostream>
    using namespace std;

    double refcube(const double &ra){
        cout <<"re address = "<<&ra<<endl;
        return ra * ra * ra;
    }

    int main (){
    
        int l = 10;
        const int & q = l;
        cout <<"q address = "<<&q<<endl;
        refcube(q);

        cout<<endl;

        double m = 3.14;
        const double & n = m;
        cout <<"n address = "<<&n<<endl;
        refcube(n);

        cout<<endl;

        double z = 3.14;
        cout <<"z address = "<<&z<<endl;
        refcube(z);

        cout<<endl;

        int y = 4;
        cout <<"y address = "<<&y<<endl;
        refcube(y);

        cout<<endl;

        int x = 5;
        cout <<"x address = "<<&x<<endl;
        refcube(std::move(x));

        return 0;
    }


    /* 执行结果:
        q  address = 0x7fff096d2ee4
        re address = 0x7fff096d2ee8  <=传入类型不匹配的常引用(1)

        n  address = 0x7fff096d2ed8
        re address = 0x7fff096d2ed8  <=传入类型匹配的常引用(2)

        z  address = 0x7fff096d2ed0
        re address = 0x7fff096d2ed0  <=传入类型匹配的左值(3)

        y  address = 0x7fff096d2ecc
        re address = 0x7fff096d2ef0  <=传入类型不匹配的左值(4)

        x  address = 0x7fff096d2ec8
        re address = 0x7fff096d2ef8 <=传入右值(5)
     */
```

</details>

&emsp;&emsp;可以看到代码中列举了4种传参状况，**传入类型不匹配的常引用、传入类型匹配的常引用、传入类型匹配的左值，传入类型不匹配的左值和传入右值**。输出结果中，只有(2)(3)情况函数内外的地址是相同。这说明其他情况下，函数内部使用的是入参副本，这很有意思。

&emsp;&emsp;书上提到早期的C++是这样运行下面代码的(当然现在不可以了，C++98就不行了)。代码执行时，由于参数类型不匹配，函数内部会将参数进行拷贝并生成两个临时变量，然后函数内部交换值但是外部a和b还是不变(所以说这是早期解决传入参数不正规,防止原变量值被修改的一种机制)。当然现在C++机制是不能成功编译下面代码的，它禁止生成临时变量，由于参数类型不匹配，编译报错。

```c++
        //内部交互形参数值
        void swapr(int & a, int & b) // use references
        {
            int temp;

            temp = a; // use a, b for values of variables
            a = b;
            b = temp;
        }

        long a = 3, b = 5;
        swapr(a, b);
```

&emsp;&emsp;现在再看`常量引用为形参示例代码`， **double refcube(const double &ra)**函数的目的只是使用传入值而非修改，那么此时函数自动生成临时变量就不会造成不利影响，还有利于处理多种可隐式转换的类型。**在我看来，const引用做形参的机制还是和上面描述的古老机制类似的**。  

&emsp;&emsp;最后我又测试了一下，发现不止是做形参，**const引用声明时也可以被右值或者可隐式转换类型变量赋值。**



### 左值引用和右值引用

&emsp;&emsp;C++11版本前的引用在C++11中称为左值引用，C++11新引入的对右值的引用称为右值引用。

1. **左值引用可不可以绑定右值?**  可以，使用`const type &`绑定但是不能修改。但是使用引用就是为了修改绑定值，所以还需要右值引用。

2. **右值引用可不可以绑定左值?** 不能直接绑定左值，可以通过`std::move()`将左值转换为右值。

3. 左值引用变量和右值引用变量都是左值。


#### 右值引用与移动语义

&emsp;&emsp;通过移动语义，我们可以实现更为细致的内存管理。比如，从一个以后不再使用的对象复制数据时，我们可以通过移动语义手动回收这个对象可以被我们直接利用的内存数据，避免大规模的内存复制操作。是内存资源的转移而不是拷贝资源。

<details>

<summary>  右值移动语义  </summary>

```c++
        #include <iostream>
        using namespace std;
        // #define MOVE 1  //注释运行拷贝构造函数  不注释运行移动构造函数

        class A{
        private:
                    int * m_i;
        public:
                    A(int _i){
                        m_i = new int(_i);
                        cout<<"构造函数"<<endl;
                    }

                    A(const A & a){
                    cout<<"深拷贝构造函数"<<endl;
                    int temp = *(a.m_i);
                    this->m_i = new int(temp);   
                    }

                    A(A && a){
                        cout<<"移动构造函数"<<endl;
                        this->m_i = a.m_i;
                        a.m_i = nullptr;
                    }

                    ~A(){
                        cout<<"析构函数"<<endl;
                        if(this->m_i){
                            cout<<"销毁 this->m_i"<<endl;
                            delete  this->m_i;
                            this->m_i = nullptr;
                        }
                    }
        };


        int main(){
            A aa(10);

        #ifdef MOVE
            A bb = std::move(aa);
        #else
            A bb = aa;
        #endif

            return 0;
        }

        /*执行结果:

            构造函数     <=====  执行移动构造函数
            移动构造函数
            析构函数
            销毁 this->m_i  <===== 资源只有一份所以只销毁一次
            析构函数

            =======================================

            构造函数       <====== 执行拷贝构造函数
            深拷贝构造函数
            析构函数
            销毁 this->m_i <====== 资源被拷贝了一份，所以有两份，需要销毁两次
            析构函数
            销毁 this->m_i

         */
```
</details>



#### 右值引用与完美转发

&emsp;&emsp;先解释一下`完美转发`,函数模板可以将自己的参数**完美地**转发给内部调用的其他函数，这里的**完美**指不仅能准确地转发参数的值，还能保证被转发的参数的左右值属性不变。

&emsp;&emsp;在C++11以前函数模板传值如下,但无论向模板函数传递左值类型还是右值类型参数，最后调用fun函数时t的属性都是左值类型。这样右值参数的值类型就丢失了，是不完美的。

<details>

<summary> C++11前的函数模板转发参数 </summary>

```c++
        #include <iostream>
        using namespace std;

        //如果入参是左值则走此函数
        void fun(int &n){
            cout<<"left n = "<<n<<endl;
        }

        //如果入参是右值则走此函数
        void fun(int &&n){
            cout<<"right n = "<<n<<endl;
        }

        //函数模板
        template<class T>
        void Fun(T t){
            fun(t);
        }

        int main(){

            int i = 10;
            int &m = i;

            Fun<int &>(m);   //左值引用传参
            Fun<int &&>(100);//右值引用传参

            return 0;
        }

        /*
            //发现向模板函数中传入左值和右值类型，最后在使用时都会变成左值类型
            left n = 10
            left n = 100
        */ 
```

</details>

&emsp;&emsp;在C++11中借助了两个技术实现了完美转发，`万能引用 T &&t`和`std::forward()`。


##### 万能引用

&emsp;&emsp;在模板中，`&&`表示的不是右值引用，而是万能引用。**万能引用可以将传入的左值和左值引用转换为左值引用，将传入的右值和右值引用转换为右值引用。【先这么浅显的理解】**

```c++
    void PerfectForward(T&& t)
    {
        Fun(forward<T>(t));
    }
```

&emsp;&emsp;在入参转换完毕后，t被转换成了左值(左值引用和右值引用都是左值)，那么再传入别的函数还是传的一个左值，这就和完美转发差一点，没有传递值的类型。这时候使用`std::forward<T> v`再进行转换，**如果T是左值引用则将v转换为T类型的左值,如果T是右值引用则将v转换为T类型的右值，这样完美转发的过程就完整了。**

<details>

<summary> 右值引用-函数模板完美转发 </summary>

```c++
        #include <iostream>
        using namespace std;

        void fun(int &n){
            cout<<"left n = "<<n<<endl;
        }

        void fun(int &&n){
            cout<<"right n = "<<n<<endl;
        }

        //完美转发的函数模板
        template<class T>
        void Fun(T &&t){
            fun(std::forward<T>(t));
        }

        int main(){

            int i = 10;
            int &m = i;

            Fun<int &>(m);
            Fun<int &&>(100);
            return 0;
        }

        /* 执行结果:
            left n = 10
            right n = 100  
         */
```

</details>